"use strict";
const stream_1 = require("stream");
const pDefer = require("p-defer");
const util_1 = require("util");
const log = util_1.debuglog('s2i');
//const log = console.log
const EOS = Symbol('EOS');
const UNINITIALIZED = Symbol('UNINITIALIZED');
const ASYNC_ITERATOR_NOT_FOUND = Symbol();
var State;
(function (State) {
    State[State["Main"] = 0] = "Main";
    State[State["Finished"] = 1] = "Finished";
})(State || (State = {}));
class IteratorWritable extends stream_1.Writable {
    constructor(opts) {
        super(opts);
        log('constructor');
        this.end = this.end2.bind(this);
        this.previousValue = UNINITIALIZED;
        this.state = State.Main;
        this.run();
    }
    async run() {
        this.once('error', err => {
            this.state = State.Finished;
            this.err = err;
        });
        while (this.state !== State.Finished) {
            log(`state transition: ${State[this.state]}`);
            this.writeBox = pDefer();
            this.iteratorConsumed = pDefer();
            this.previousValue = await this.writeBox.promise;
            await this.iteratorConsumed.promise;
            if (this.previousValue === EOS) {
                this.state = State.Finished;
            }
            // else continue
        }
    }
    _write(chunk, encoding, callback) {
        ;
        (async () => {
            try {
                await this.writeAsync(chunk, encoding);
                callback();
            }
            catch (err) {
                callback(err);
            }
        })();
    }
    async writeAsync(chunk, enc) {
        log(`write: ${chunk}`);
        if (this.state != State.Main) {
            throw new Error('Not ready for writing.');
        }
        this.writeBox.resolve(chunk);
    }
    endRequest() {
        log('end');
        if (this.state != State.Main) {
            throw new Error('Not ready for writing.');
        }
        this.writeBox.resolve(EOS);
    }
    end2(chunk, enc, cb) {
        enc
            ? super.end(chunk, enc, () => this.endRequest())
            : super.end(chunk, () => this.endRequest());
    }
    async next() {
        log('next');
        if (this.state === State.Finished) {
            const { err } = this;
            if (err) {
                throw err;
            }
            return { done: true };
        }
        this.iteratorConsumed.resolve(true);
        const val = await this.writeBox.promise;
        log(`returning value to iterator`, val);
        if (val === EOS) {
            return { done: true };
        }
        else {
            return { done: false, value: val };
        }
    }
    async init() {
        log('init');
        this.iteratorConsumed.resolve(true);
        this.previousValue = await this.writeBox.promise;
        return this;
    }
    legacyNext() {
        log(`legacyNext`);
        if (this.state === State.Finished) {
            const { err } = this;
            if (err) {
                throw err;
            }
            return { done: true };
        }
        const { previousValue } = this;
        if (previousValue === UNINITIALIZED) {
            throw new Error('Must call init() first.');
        }
        if (previousValue === EOS) {
            return { done: true };
        }
        else {
            return {
                done: false,
                value: (async () => {
                    this.iteratorConsumed.resolve(true);
                    await this.writeBox.promise;
                    return previousValue;
                })()
            };
        }
    }
    [Symbol.asyncIterator || ASYNC_ITERATOR_NOT_FOUND]() {
        return this;
    }
    [Symbol.iterator]() {
        const o = {
            init: async () => {
                await this.init();
                return o;
            },
            next: () => this.legacyNext(),
            [Symbol.iterator]: () => o
        };
        return o;
    }
}
module.exports = IteratorWritable;
//# sourceMappingURL=iterator-writable.js.map